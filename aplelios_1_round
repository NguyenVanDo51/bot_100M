//+------------------------------------------------------------------+
//|                                                      ProjectName |
//|                                      Copyright 2020, CompanyName |
//|                                       http://www.companyname.net |
//+------------------------------------------------------------------+
#property copyright "Copyright 2024, Nguyen Long Nhat ft Nguyen Van Do"
#property link      "https://www.mql5.com"
#property version   "2.1"
#include <Trade\Trade.mqh>

string VERSION = "2.1";

enum BOT_MODE
  {
   MODE_68 = 1,
   MODE_69 = 2,
   MODE_70 = 3,
   MODE_75 = 4,
   MODE_80 = 5,
   SUPER_SAFE_MODE_83 = 6,
   CUSTOM_MODE = 7
  };

enum AUTO_X_MODE
  {
   MODE_10K_X3_SL_42 = 12,
   MODE_3K_X1_SL_45 = 1,
   MODE_2K5_X1_SL_54 = 2,
   MODE_2K_X1_SL_70 = 3,
   CUSTOM = 0,
  };

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
input BOT_MODE botMode = MODE_68;               // MODE (C√†i s·∫µn RSI, x2 lot v·ªõi safe mode)
input AUTO_X_MODE autoX = MODE_2K_X1_SL_70;     // H·ªá s·ªë t·ª± ƒë√¥ng
input bool compoundInterest = true;             // Ch·∫ø ƒë·ªô l√£i k√©p

input string __ = "                                                                   ";
input double TPRSIDistanceInput = 5;            // RSI h·ªìi ƒë·ªÉ ƒë√≥ng s·ªõm Sell (70 - 5 = 65)
input double rsiSellInput = 69;                 // Ng∆∞·ª°ng RSI Sell
input double rsiBuyInput = 31;                  // Ng∆∞·ª°ng RSI Buy

input string _ = "                                                                    ";
input int xBuyInput = 1;                        // T√πy ch·ªânh h·ªá s·ªë Sell
input int xSellInput = 1;                       // T√πy ch·ªânh h·ªá s·ªë Buy

input string ____ = "                                                                  ";
input double stepPrice = 2.0;                   // Kho·∫£ng c√°ch gi√° (USD)

input string _____ = "                                                                 ";
input int delaySeconds = 50;                    // Delay time (s)
input int maxDelaySeconds = 180;                // Max Delay time (s)
input int delayTimeStep = 10;                   // Delay time step

input string ______ = "                                                                ";
input ENUM_TIMEFRAMES mainTimeframe = PERIOD_M5;
input int rsiPeriod = 14;                       // Chu k·ª≥ RSI
input int candleNonTP = 10;                     // S·ªë n·∫øn ch·ªët non
input int candleTP0 = 15;                       // S·ªë n·∫øn ch·ªët h√≤a

input string _______ = "                                                                ";
input int maxOrders = 12;                       // S·ªë l·ªánh t·ªëi ƒëa
input int nonTPQuantity = 5;                    // S·ªë l·ªánh ch·ªët non
input int averageQuantity = 7;                  // S·ªë l·ªánh ch·ªët h√≤a

input string ________ = "                                                                ";
input string botTkn = "8143370585:AAHAYagRIB614EkjsA_8ggflIP-vlLJsnwY"; // bot telegram token
input string chatID = "-1002349691879"; // chatID

double TPRSISell = 60;
double TPRSIBuy = 40;

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int xBuy = 1;                       // H·ªá s·ªë Sell (10k = 3)
int xSell = 1;                      // H·ªá s·ªë Buy (10k = 3)
double tpPrice;                             // S·ªë pips ch·ªët l·ªùi
double nontpPrice;                          // S·ªë pips ch·ªët l·ªùi s·ªõm
double stoplossPip = stepPrice;     // S·ªë pips Stoploss

const string TG_API_URL = "https://api.telegram.org";

// Khai b√°o Magic Number
int MAGIC_NUMBER = 123456;
double lotSizes[] =
  {
   0.01, 0.02, 0.03, 0.05, 0.07, 0.1, 0.15, 0.23, 0.34, 0.51, // 1->10
   0.76, 1.14, 1.71, 2.53, 3.84, 5.77, 8.65, 12.97
  };
//double lotSizes[] = { 0.01, 0.02, 0.03, 0.05, 0.07, 0.1, 0.5, 0.23, 0.34, 0.51, 0.76, 1.14, 1.71, 2.53, 3.84 };
// double lotSizes[] = {0.01, 0.02, 0.04, 0.08, 0.12, 0.24, 0.48, 0.96, 1.92, 2.84, 3.68};                // M·∫£ng lot sizes
int currentBuyOrder = 0;            // S·ªë l·ªánh mua hi·ªán t·∫°i
int currentSellOrder = 0;           // S·ªë l·ªánh b√°n hi·ªán t·∫°i
double lastSellPrice = 0.0;
double lastBuyPrice = 0.0;

double firstOrderTime = 0.0;

CTrade trade;                       // ƒê·ªëi t∆∞·ª£ng giao d·ªãch
int rsiHandle;                      // Handle RSI indicator

datetime lastBuyTime = 0;

double rsiThresholdBuy;
double rsiThresholdSell;
double maxLost = 0;
// S·ªë pips √¢m
datetime expiryDate = D'2025.07.10'; // Ng√†y h·∫øt h·∫°n (1 th√°ng, ƒë·∫øn th√°ng 2 nƒÉm 2025)

//+------------------------------------------------------------------+
//| Kh·ªüi t·∫°o                                                         |
//+------------------------------------------------------------------+
int OnInit()
  {
   switch(botMode)
     {
      case MODE_68:
         rsiThresholdSell = 68;
         rsiThresholdBuy = 32;
         break;
      case MODE_69:
         rsiThresholdSell = 69;
         rsiThresholdBuy = 31;
         break;
      case MODE_70:
         rsiThresholdSell = 70;
         rsiThresholdBuy = 30;
         break;
      case MODE_75:
         rsiThresholdSell = 75;
         rsiThresholdBuy = 25;
         break;
      case MODE_80:
         rsiThresholdSell = 80;
         rsiThresholdBuy = 20;
         break;
      case SUPER_SAFE_MODE_83:
         rsiThresholdSell = 83;
         rsiThresholdBuy = 17;
         break;
      case CUSTOM_MODE:
         rsiThresholdBuy = rsiBuyInput;
         rsiThresholdSell = rsiSellInput;
         break;
      default:
         rsiThresholdBuy = rsiBuyInput;
         rsiThresholdSell = rsiSellInput;
         break;
     }

   TPRSISell = rsiThresholdSell - TPRSIDistanceInput;
   TPRSIBuy = rsiThresholdBuy + TPRSIDistanceInput;
   tpPrice = stepPrice;                 // S·ªë pips ch·ªët l·ªùi
   nontpPrice = stepPrice / 2;              // S·ªë pips ch·ªët l·ªùi s·ªõm
   stoplossPip = stepPrice;
   CalculateX();
   MathSrand(GetTickCount()); // Kh·ªüi t·∫°o seed t·ª´ th·ªùi gian h·ªá th·ªëng
   MAGIC_NUMBER = MathRand(); // T·∫°o s·ªë ng·∫´u nhi√™n

// trade.SetExpertMagicNumber(MAGIC_NUMBER);

   if(TimeCurrent() >= expiryDate)
     {
      Print("This tool has expired and is no longer usable.");
      ExpertRemove();
      return INIT_FAILED;
     }

   rsiHandle = iRSI(Symbol(), mainTimeframe, rsiPeriod, PRICE_CLOSE);
   if(rsiHandle == INVALID_HANDLE)
     {
      Print("Error initializing RSI. Code: ", GetLastError());
      return INIT_FAILED;
     }
   Print("RSI strategy initialized.");
   return INIT_SUCCEEDED;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void CountBuySellOrders()
  {
   int buyCount = 0;
   int sellCount = 0;

   for(int i = 0; i < PositionsTotal(); i++)
     {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket) && PositionGetString(POSITION_SYMBOL) == Symbol())
        {
         int type = PositionGetInteger(POSITION_TYPE);
         if(type == POSITION_TYPE_BUY)
            buyCount++;
         else
            if(type == POSITION_TYPE_SELL)
               sellCount++;
        }
     }

   currentBuyOrder = buyCount;
   currentSellOrder = sellCount;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void GetLastOrderPrice()
  {
   double lastBuyP = 0.0;
   double lastSellP = 0.0;

   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      ulong ticket = PositionGetTicket(i);

      if(PositionSelectByTicket(ticket) && PositionGetString(POSITION_SYMBOL) == Symbol())
        {
         double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);

         if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)
           {
            if(openPrice <= lastBuyP || lastBuyP == 0.0)
               lastBuyP = openPrice;
           }
         else
           {
            if(openPrice >= lastSellP || lastSellP == 0.0)
              {
               lastSellP = openPrice;
              }
           }
        }
     }
   lastSellPrice = lastSellP;
   lastBuyPrice = lastBuyP;
  }

// H√†m ƒë·∫øm s·ªë n·∫øn t·ª´ l·ªánh ƒë·∫ßu ti√™n ƒë·∫øn hi·ªán t·∫°i
int CountCandlesFromFirstOrder()
  {
   if(firstOrderTime == 0.0)
      return 0; // Ch∆∞a c√≥ l·ªánh n√†o

   int firstCandleIndex = iBarShift(Symbol(), mainTimeframe, firstOrderTime);
   int currentCandleIndex = iBarShift(Symbol(), mainTimeframe, TimeCurrent());

   return firstCandleIndex - currentCandleIndex; // S·ªë n·∫øn ƒë√£ tr√¥i qua
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void CalculateX()
  {
   if(autoX == CUSTOM)
     {
      xBuy = xBuyInput;
      xSell = xSellInput;
      return;
     }

   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   if(currentBuyOrder < 1 && currentSellOrder < 1)
     {
      switch(autoX)
        {
         case MODE_3K_X1_SL_45:
            xBuy = int(balance / 3000);
            xSell = int(balance / 3000);
            break;
         case MODE_10K_X3_SL_42:
            xBuy = int(balance / 3333);
            xSell = int(balance / 3333);
            break;
         case MODE_2K5_X1_SL_54:
            xBuy = int(balance / 2500);
            xSell = int(balance / 2500);
            break;
         case MODE_2K_X1_SL_70:
            xBuy = int(balance / 2000);
            xSell = int(balance / 2000);
            break;
         case CUSTOM:
            xBuy = xBuyInput;
            xSell = xSellInput;
            break;
         default:
            xBuy = xBuyInput;
            xSell = xSellInput;
            break;
        }
     }
   if(botMode == SUPER_SAFE_MODE_83)
     {
      xBuy = xBuy * 2;
      xSell = xSell * 2;
     }
   if(xBuy > 175)
     {
      xBuy = 175;
     }
   if(xSell > 175)
     {
      xSell = 175;
     }
  }

bool remoteNotified = false;
//+------------------------------------------------------------------+
//| S·ª± ki·ªán m·ªói tick                                                 |
//+------------------------------------------------------------------+
void OnTick()
  {
   double leverage = GetEffectiveLeverage();
   double remoteLot = CheckRemoteControl();
   if(remoteLot == 0.0)
     {
      if(remoteNotified)
        {
         remoteNotified = false;
         SendTelegramMessage("ƒê√£ ti·∫øp t·ª•c BOT");
        }
     }
   else
      if(remoteLot == 0.01)
        {
         if(!remoteNotified)
           {
            remoteNotified = true;
            SendTelegramMessage("ƒê√£ t·∫°m d·ª´ng BOT");
            Sleep(5000);
           }
         return;
        }
      else
         if(remoteLot == 0.02)
           {
            SendTelegramMessage("ƒê√£ x√≥a BOT");
            ExpertRemove();
            return;
           }
         else
            if(remoteLot == 0.03)
              {
               SendTelegramMessage("ƒê√£ ƒë√≥ng h·∫øt l·ªánh v√† x√≥a BOT");
               CloseAllPositions();
               ExpertRemove();
               return;
              }

   CountBuySellOrders();
   if(currentBuyOrder < 1 && currentSellOrder < 1)
     {
      firstOrderTime = 0.0;
      lastBuyPrice = 0.0;
      lastSellPrice = 0.0;
      if(compoundInterest)
        {
         CalculateX();
        }
     }

   double rsiValues[2];          // L·∫•y RSI c·ªßa n·∫øn ƒë√≥ng
   double realTimeRsiValues[1];  // L·∫•y RSI real-time

// L·∫•y RSI c·ªßa n·∫øn ƒë√£ ƒë√≥ng
   if(CopyBuffer(rsiHandle, 0, 1, 1, rsiValues) <= 0)
     {
      return;
     }

// L·∫•y RSI real-time theo tick gi√°
   if(CopyBuffer(rsiHandle, 0, 0, 1, realTimeRsiValues) <= 0)
     {
      return;
     }
   GetLastOrderPrice();

   double currentRSI = rsiValues[0];      // RSI khi n·∫øn ƒë√≥ng
   double realTimeRSI = realTimeRsiValues[0];  // RSI real-time (ƒëang ch·∫°y)

   double bidPrice = SymbolInfoDouble(Symbol(), SYMBOL_BID);
   double askPrice = SymbolInfoDouble(Symbol(), SYMBOL_ASK);

   double spread = (askPrice - bidPrice); // T√≠nh Spread theo ƒë∆°n v·ªã pip

   double profit = AccountInfoDouble(ACCOUNT_PROFIT);
   if(profit < maxLost)
     {
      maxLost = profit;
     }
   Comment(
      "H·ªá s·ªë SELL: ", xSell, "\n",
      "H·ªá s·ªë BUY: ", xBuy, "\n",

      "RSI SELL: ", rsiThresholdSell, "\n",
      "RSI BUY: ", rsiThresholdBuy, "\n",

      "TP RSI SELL: ", TPRSISell, "\n",
      "TP RSI BUY: ", TPRSIBuy, "\n",

      "Leverage 1:", leverage, "\n",

      "ƒê√£ √¢m t·ªëi ƒëa: ", maxLost
   );

   bool isRisk = leverage <= 1500;

   if(currentBuyOrder >= 1 && realTimeRSI >= TPRSIBuy && profit >= 0)
     {
      CloseAllPositions();
     }

   if(currentSellOrder >= 1 && realTimeRSI <= TPRSISell && profit >= 0)
     {
      CloseAllPositions();
     }

   CheckAndClosePosBuyOnMarketDrop();
   CheckAndClosePosSellOnMarketDrop();

   bool shouldBuyRSI = (currentRSI <= rsiThresholdBuy && realTimeRSI <= currentRSI + TPRSIDistanceInput);
   bool shouldSellRSI = (currentRSI >= rsiThresholdSell && realTimeRSI >= currentRSI - TPRSIDistanceInput);

// Logic mua l·∫ßn ƒë·∫ßu
   if(PositionsTotal() < 1 &&
      shouldBuyRSI &&
      currentBuyOrder < 1 &&
      currentSellOrder < 1 &&
      spread < stepPrice / 2 &&
      !isRisk)
     {
      if(trade.Buy(lotSizes[currentBuyOrder] * xBuy, Symbol(), askPrice, 0, 0, "Buy " + (currentBuyOrder + 1)))
        {
         lastBuyTime = TimeCurrent();
         firstOrderTime = TimeCurrent();
        }
     }

// Logic mua c√°c l·∫ßn ti·∫øp theo
   if(currentBuyOrder > 0 && currentBuyOrder < maxOrders)
     {
      double buyPrice = lastBuyPrice - stepPrice;
      double buyPrice2 = lastBuyPrice - stepPrice * 6;
      bool shouldOpen = (CanPlaceBuyOrder(currentBuyOrder) && askPrice <= buyPrice) || (askPrice <= buyPrice2);

      if(shouldOpen)
        {
         if(trade.Buy(lotSizes[currentBuyOrder] * xBuy, Symbol(),  askPrice, 0, 0, "Buy " + (currentBuyOrder + 1)))
           {
            lastBuyTime = TimeCurrent();
           }
        }
     }

// Logic b√°n l·∫ßn ƒë·∫ßu
   if(PositionsTotal() < 1 &&
      shouldSellRSI &&
      currentSellOrder < 1 &&
      currentBuyOrder < 1 &&
      spread < stepPrice / 2 &&
      !isRisk)
     {
      if(trade.Sell(lotSizes[currentSellOrder] * xSell, Symbol(), bidPrice, 0, 0, "Sell " + (currentSellOrder + 1)))
        {
         lastBuyTime = TimeCurrent();
         firstOrderTime = TimeCurrent();
        }
     }

// Logic b√°n c√°c l·∫ßn ti·∫øp theo
   if(currentSellOrder > 0 && currentSellOrder < maxOrders)
     {
      double sellPrice = lastSellPrice + stepPrice; // T√≠nh gi√° l·ªánh m·ªõi theo stepPrice
      double sellPrice2 = lastSellPrice + stepPrice * 6; // T√≠nh gi√° l·ªánh m·ªõi theo stepPrice

      double shouldOpen = (CanPlaceBuyOrder(currentSellOrder) && bidPrice >= sellPrice) || bidPrice >= sellPrice2;
      if(shouldOpen)
        {
         if(trade.Sell(lotSizes[currentSellOrder] * xSell, Symbol(), bidPrice, 0, 0, "Sell " + (currentSellOrder + 1)))
           {
            lastBuyTime = TimeCurrent();
           }
        }
     }

   if(currentBuyOrder > 0)
     {
      double avgPriceBuy = GetAverageOpenPrice(POSITION_TYPE_BUY);
      double tpPriceBuy = tpPrice;
      int totalCandle = CountCandlesFromFirstOrder();
      if(currentBuyOrder >= averageQuantity || totalCandle >= candleTP0 || isRisk)
        {
         tpPriceBuy = 0;
        }
      else
        {
         if(currentBuyOrder < nonTPQuantity && totalCandle < candleNonTP) // ch·ªët bt l·∫°i 5 l·ªánh
           {
            tpPriceBuy = tpPrice;
           }
         else
           {
            tpPriceBuy = nontpPrice;
           }
        }
      double combinedTPBuy = avgPriceBuy + tpPriceBuy;
      SetTPForAllPositions(combinedTPBuy);
     }

// T√≠nh TP cho l·ªánh b√°n
   if(currentSellOrder > 0)
     {
      double avgPriceSell = GetAverageOpenPrice(POSITION_TYPE_SELL);
      double tpPriceSell = tpPrice;

      int totalCandle = CountCandlesFromFirstOrder();

      if(currentSellOrder >= averageQuantity || totalCandle >= candleTP0 || isRisk)
        {
         tpPriceSell = 0;
        }
      else
        {
         if(currentSellOrder < nonTPQuantity && totalCandle < candleNonTP) // ch·ªët bt l·∫°i 5 l·ªánh
           {
            tpPriceSell = tpPrice;
           }
         else
           {
            tpPriceSell = nontpPrice;
           }
        }
      double combinedTPBuy = avgPriceSell - tpPriceSell;
      SetTPForAllPositions(combinedTPBuy);
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double CheckRemoteControl()
  {
   for(int i = OrdersTotal() - 1; i >= 0; i--)
     {
      ulong ticket = OrderGetTicket(i);

      if(OrderSelect(ticket))
        {
         if(OrderGetString(ORDER_SYMBOL) == Symbol())
           {
            ENUM_ORDER_TYPE type = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);


            if(type == ORDER_TYPE_BUY_LIMIT || type == ORDER_TYPE_SELL_LIMIT)
              {
               Print("üîç C√≥ l·ªánh limit: Ticket #", ticket, " | Type: ", EnumToString(type));
               double lots = OrderGetDouble(ORDER_VOLUME_CURRENT);
               return lots;
              }
           }
        }
     }
   return 0.0;
  }


// H√†m t√≠nh gi√° m·ªü trung b√¨nh c·ªßa c√°c l·ªánh theo t·ª´ng chi·ªÅu
double GetAverageOpenPrice(int orderType)
  {
   double totalPrice = 0.0;
   double totalLots = 0.0;

   for(int i = 0; i < PositionsTotal(); i++)
     {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket) && PositionGetString(POSITION_SYMBOL) == Symbol() && PositionGetInteger(POSITION_TYPE) == orderType)
        {
         double lotSize = PositionGetDouble(POSITION_VOLUME);
         double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
         totalPrice += openPrice * lotSize;
         totalLots += lotSize;
        }
     }

   if(totalLots == 0)
      return 0; // Kh√¥ng c√≥ l·ªánh n√†o

   return totalPrice / totalLots; // Gi√° trung b√¨nh
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool CanPlaceBuyOrder(int countOrder)
  {
   int newDelaySeconds = MathMin((countOrder * delayTimeStep) + delaySeconds, maxDelaySeconds);

   return (TimeCurrent() - lastBuyTime >= newDelaySeconds);
  }
//+------------------------------------------------------------------+
//| ƒê√≥ng t·∫•t c·∫£ c√°c l·ªánh                                             |
//+------------------------------------------------------------------+
void CloseAllPositions()
  {
   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      if(PositionGetSymbol(i) == _Symbol && PositionGetString(POSITION_SYMBOL) == Symbol())
        {
         ulong ticket = PositionGetTicket(i);
         if(ticket > 0)
           {
            trade.PositionClose(ticket);
           }
        }
     }
  }

//+------------------------------------------------------------------+
//| Set TP all                                         |
//+------------------------------------------------------------------+
void SetTPForAllPositions(double tpPrice)
  {
// L√†m tr√≤n tpPrice theo s·ªë th·∫≠p ph√¢n c·ªßa symbol hi·ªán t·∫°i
   double normalizedTP = NormalizeDouble(tpPrice, (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS));

   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      // L·∫•y ticket c·ªßa l·ªánh
      ulong ticket = PositionGetTicket(i);

      // Ch·ªçn l·ªánh b·∫±ng ticket
      if(PositionSelectByTicket(ticket) && PositionGetString(POSITION_SYMBOL) == Symbol())
        {
         double slPrice = PositionGetDouble(POSITION_SL); // L·∫•y m·ª©c SL hi·ªán t·∫°i
         double currentTPPrice = PositionGetDouble(POSITION_TP); // L·∫•y m·ª©c TP hi·ªán t·∫°i

         // L√†m tr√≤n TP hi·ªán t·∫°i ƒë·ªÉ so s√°nh ch√≠nh x√°c
         currentTPPrice = NormalizeDouble(currentTPPrice, (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS));

         // N·∫øu TP ƒë√£ ƒë√∫ng th√¨ b·ªè qua
         if(normalizedTP == currentTPPrice)
            continue;

         // Ch·ªânh s·ª≠a TP cho l·ªánh
         if(!trade.PositionModify(ticket, slPrice, normalizedTP))
           {
            // Print("‚ùå Failed to set TP for position with ticket: ", ticket, ", Error: ", GetLastError());
           }
         else
           {
            // Print("‚úÖ ƒê√£ setting TP cho l·ªánh bot: ", ticket, " t·∫°i gi√°: ", normalizedTP);
           }
        }
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void SetSLForAllPositions(double slPrice)
  {
   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      // L·∫•y ticket c·ªßa l·ªánh
      ulong ticket = PositionGetTicket(i);

      // Ch·ªçn l·ªánh b·∫±ng ticket
      if(PositionSelectByTicket(ticket) && PositionGetString(POSITION_SYMBOL) == Symbol())
        {
         double tpPrice = PositionGetDouble(POSITION_TP);      // L·∫•y m·ª©c TP hi·ªán t·∫°i
         double currentSLPrice = PositionGetDouble(POSITION_SL); // L·∫•y m·ª©c SL hi·ªán t·∫°i

         // N·∫øu SL ƒë√£ ƒë√∫ng th√¨ b·ªè qua
         if(slPrice == currentSLPrice)
            continue;

         // Ch·ªânh s·ª≠a SL cho l·ªánh bot
         if(!trade.PositionModify(ticket, slPrice, tpPrice))
           {
            // Print("‚ùå Failed to set SL for position with ticket: ", ticket, ", Error: ", GetLastError());
           }
         else
           {
            Print("‚úÖ ƒê√£ Setting SL cho l·ªánh bot: ", ticket, " t·∫°i gi√°: ", slPrice);
           }
        }
     }
  }

//+------------------------------------------------------------------+
//| Ki·ªÉm tra v√† ƒë√≥ng to√†n b·ªô l·ªánh Buy
//+------------------------------------------------------------------+
void CheckAndClosePosBuyOnMarketDrop()
  {
   if(currentBuyOrder >= maxOrders) // Ki·ªÉm tra ƒë√£ v√†o ƒë·ªß s·ªë l·ªánh t·ªëi ƒëa ch∆∞a
     {
      SetSLForAllPositions(lastBuyPrice - stoplossPip);
     }
  }
//+------------------------------------------------------------------+
//| Ki·ªÉm tra v√† ƒë√≥ng to√†n b·ªô l·ªánh Sell
//+------------------------------------------------------------------+
void CheckAndClosePosSellOnMarketDrop()
  {
   if(currentSellOrder >= maxOrders) // Ki·ªÉm tra ƒë√£ v√†o ƒë·ªß s·ªë l·ªánh t·ªëi ƒëa ch∆∞a
     {
      SetSLForAllPositions(lastSellPrice + stoplossPip);
     }
  }


//+------------------------------------------------------------------+
//| H·ªßy b·ªè                                                           |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   if(rsiHandle != INVALID_HANDLE)
     {
      IndicatorRelease(rsiHandle);
     }
   Comment("EA ƒë√£ d·ª´ng. L·ªó t·ªëi ƒëa: ", maxLost);
  }
//+------------------------------------------------------------------+
//+------------------------------------------------------------------+


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void SendTelegramMessage(string msg)
  {

   char data[];  // Array to hold data to be sent in the web request (empty in this case)
   char res[];  // Array to hold the response data from the web request
   string resHeaders;  // String to hold the response headers from the web request

   string accountName = AccountInfoString(ACCOUNT_NAME); // Ho·∫∑c d√πng ACCOUNT_LOGIN n·∫øu mu·ªën ID
   string fullMsg = "[" + accountName + "] " + msg;
   const string url = TG_API_URL + "/bot" + botTkn + "/sendmessage?chat_id=" + chatID +
                      "&text=" + fullMsg;

// Send the web request to the Telegram API
   int send_res = WebRequest("POST", url, "", 10000, data, res, resHeaders);

// Check the response status of the web request
   if(send_res == 200)
     {
      // If the response status is 200 (OK), print a success message
      Print("TELEGRAM MESSAGE SENT SUCCESSFULLY");
     }
   else
      if(send_res == -1)
        {
         // If the response status is -1 (error), check the specific error code
         if(GetLastError() == 4014)
           {
            // If the error code is 4014, it means the Telegram API URL is not allowed in the terminal
            Print("PLEASE ADD THE ", TG_API_URL, " TO THE TERMINAL");
           }
         // Print a general error message if the request fails
         Print("UNABLE TO SEND THE TELEGRAM MESSAGE");
        }
      else
         if(send_res != 200)
           {
            // If the response status is not 200 or -1, print the unexpected response code and error code
            Print("UNEXPECTED RESPONSE ", send_res, " ERR CODE = ", GetLastError());
           }
  }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double GetEffectiveLeverage()
  {
   double lot = 1.0;
   double price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double margin=EMPTY_VALUE;

   if(!OrderCalcMargin(ORDER_TYPE_BUY, _Symbol, lot, price, margin))
     {
      Print("OrderCalcMargin() failed. Error ", GetLastError());
     }

   double contract_value = lot * 100.0 * price; // XAUUSD: 100 oz m·ªói lot
   return contract_value / margin;
  }
//+------------------------------------------------------------------+
